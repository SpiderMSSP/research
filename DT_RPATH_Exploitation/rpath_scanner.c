/*
 * rpath_scanner.c - DT_RPATH/DT_RUNPATH Vulnerability Scanner
 *
 * This utility scans ELF binaries to find potentially exploitable
 * library search paths. It looks for:
 *
 *   1. DT_RPATH/DT_RUNPATH pointing to user-writable directories
 *   2. Relative paths (exploitable if binary can be moved/symlinked)
 *   3. $ORIGIN paths (exploitable in certain scenarios)
 *   4. Non-existent directories (can be created by attacker)
 *
 * Compile: gcc -o rpath_scanner rpath_scanner.c
 * Usage:   ./rpath_scanner <binary>
 *          ./rpath_scanner --scan-system
 *
 * EDUCATIONAL PURPOSES ONLY
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <elf.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <dirent.h>
#include <errno.h>
#include <pwd.h>

/* Color codes */
#define RED     "\033[1;31m"
#define GREEN   "\033[1;32m"
#define YELLOW  "\033[1;33m"
#define BLUE    "\033[1;34m"
#define CYAN    "\033[1;36m"
#define RESET   "\033[0m"

/* ═══════════════════════════════════════════════════════════════════════════
 * ELF PARSING
 * ═══════════════════════════════════════════════════════════════════════════ */

typedef struct {
    char *rpath;
    char *runpath;
    char *needed_libs[64];
    int needed_count;
} elf_info_t;

int parse_elf(const char *filename, elf_info_t *info) {
    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        return -1;
    }

    struct stat st;
    if (fstat(fd, &st) < 0 || st.st_size < (off_t)sizeof(Elf64_Ehdr)) {
        close(fd);
        return -1;
    }

    void *map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (map == MAP_FAILED) {
        close(fd);
        return -1;
    }

    Elf64_Ehdr *ehdr = (Elf64_Ehdr *)map;

    /* Verify ELF magic */
    if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0) {
        munmap(map, st.st_size);
        close(fd);
        return -1;
    }

    /* Initialize info */
    memset(info, 0, sizeof(*info));

    /* Find dynamic section */
    Elf64_Phdr *phdr = (Elf64_Phdr *)((uint8_t *)map + ehdr->e_phoff);
    Elf64_Dyn *dynamic = NULL;
    char *strtab = NULL;
    size_t strtab_size = 0;

    for (int i = 0; i < ehdr->e_phnum; i++) {
        if (phdr[i].p_type == PT_DYNAMIC) {
            dynamic = (Elf64_Dyn *)((uint8_t *)map + phdr[i].p_offset);
            break;
        }
    }

    if (!dynamic) {
        munmap(map, st.st_size);
        close(fd);
        return 0;  /* Static binary, no dynamic section */
    }

    /* Find string table */
    for (Elf64_Dyn *d = dynamic; d->d_tag != DT_NULL; d++) {
        if (d->d_tag == DT_STRTAB) {
            /* Convert virtual address to file offset */
            for (int i = 0; i < ehdr->e_phnum; i++) {
                if (phdr[i].p_type == PT_LOAD &&
                    d->d_un.d_ptr >= phdr[i].p_vaddr &&
                    d->d_un.d_ptr < phdr[i].p_vaddr + phdr[i].p_filesz) {
                    size_t offset = d->d_un.d_ptr - phdr[i].p_vaddr + phdr[i].p_offset;
                    strtab = (char *)map + offset;
                    break;
                }
            }
        }
        if (d->d_tag == DT_STRSZ) {
            strtab_size = d->d_un.d_val;
        }
    }

    if (!strtab) {
        munmap(map, st.st_size);
        close(fd);
        return 0;
    }

    /* Extract RPATH, RUNPATH, and NEEDED entries */
    for (Elf64_Dyn *d = dynamic; d->d_tag != DT_NULL; d++) {
        if (d->d_un.d_val < strtab_size) {
            if (d->d_tag == DT_RPATH) {
                info->rpath = strdup(strtab + d->d_un.d_val);
            } else if (d->d_tag == DT_RUNPATH) {
                info->runpath = strdup(strtab + d->d_un.d_val);
            } else if (d->d_tag == DT_NEEDED && info->needed_count < 64) {
                info->needed_libs[info->needed_count++] = strdup(strtab + d->d_un.d_val);
            }
        }
    }

    munmap(map, st.st_size);
    close(fd);
    return 0;
}

void free_elf_info(elf_info_t *info) {
    if (info->rpath) free(info->rpath);
    if (info->runpath) free(info->runpath);
    for (int i = 0; i < info->needed_count; i++) {
        if (info->needed_libs[i]) free(info->needed_libs[i]);
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * VULNERABILITY CHECKS
 * ═══════════════════════════════════════════════════════════════════════════ */

typedef enum {
    VULN_NONE = 0,
    VULN_WRITABLE = 1,
    VULN_RELATIVE = 2,
    VULN_ORIGIN = 4,
    VULN_NONEXISTENT = 8,
    VULN_WORLD_WRITABLE = 16
} vuln_type_t;

int check_path_vulnerability(const char *path, uid_t uid) {
    int vulns = VULN_NONE;

    /* Check for relative path */
    if (path[0] != '/' && strncmp(path, "$ORIGIN", 7) != 0) {
        vulns |= VULN_RELATIVE;
    }

    /* Check for $ORIGIN */
    if (strstr(path, "$ORIGIN") || strstr(path, "${ORIGIN}")) {
        vulns |= VULN_ORIGIN;
    }

    /* Skip $ORIGIN paths for direct stat checks */
    if (path[0] == '$') {
        return vulns;
    }

    struct stat st;
    if (stat(path, &st) < 0) {
        if (errno == ENOENT) {
            vulns |= VULN_NONEXISTENT;

            /* Check if parent directory is writable */
            char parent[PATH_MAX];
            strncpy(parent, path, sizeof(parent) - 1);
            char *slash = strrchr(parent, '/');
            if (slash && slash != parent) {
                *slash = '\0';
                if (access(parent, W_OK) == 0) {
                    vulns |= VULN_WRITABLE;
                }
            }
        }
    } else {
        /* Directory exists - check permissions */
        if (st.st_mode & S_IWOTH) {
            vulns |= VULN_WORLD_WRITABLE;
        }
        if (st.st_uid == uid && (st.st_mode & S_IWUSR)) {
            vulns |= VULN_WRITABLE;
        }
        if (access(path, W_OK) == 0) {
            vulns |= VULN_WRITABLE;
        }
    }

    return vulns;
}

void print_vulnerability(const char *path, int vulns) {
    printf("    ");

    if (vulns & VULN_WORLD_WRITABLE) {
        printf(RED "WORLD-WRITABLE" RESET " ");
    }
    if (vulns & VULN_WRITABLE) {
        printf(RED "USER-WRITABLE" RESET " ");
    }
    if (vulns & VULN_NONEXISTENT) {
        printf(YELLOW "NON-EXISTENT" RESET " ");
    }
    if (vulns & VULN_RELATIVE) {
        printf(YELLOW "RELATIVE-PATH" RESET " ");
    }
    if (vulns & VULN_ORIGIN) {
        printf(CYAN "$ORIGIN" RESET " ");
    }

    printf("→ %s\n", path);
}

/* ═══════════════════════════════════════════════════════════════════════════
 * ANALYSIS
 * ═══════════════════════════════════════════════════════════════════════════ */

void analyze_binary(const char *filename) {
    elf_info_t info;

    if (parse_elf(filename, &info) < 0) {
        fprintf(stderr, RED "[!]" RESET " Failed to parse: %s\n", filename);
        return;
    }

    uid_t uid = getuid();
    int has_vulns = 0;

    printf("\n");
    printf(CYAN "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf(CYAN "  ANALYZING: %s\n" RESET, filename);
    printf(CYAN "═══════════════════════════════════════════════════════════════════\n" RESET);

    /* Analyze DT_RPATH */
    if (info.rpath) {
        printf("\n" YELLOW "[DT_RPATH]" RESET " (searched BEFORE LD_LIBRARY_PATH):\n");

        char *path = strtok(strdup(info.rpath), ":");
        while (path) {
            int vulns = check_path_vulnerability(path, uid);
            if (vulns) {
                has_vulns = 1;
                print_vulnerability(path, vulns);
            } else {
                printf("    " GREEN "OK" RESET " → %s\n", path);
            }
            path = strtok(NULL, ":");
        }
    } else {
        printf("\n" GREEN "[DT_RPATH]" RESET " Not set\n");
    }

    /* Analyze DT_RUNPATH */
    if (info.runpath) {
        printf("\n" YELLOW "[DT_RUNPATH]" RESET " (searched AFTER LD_LIBRARY_PATH):\n");

        char *path = strtok(strdup(info.runpath), ":");
        while (path) {
            int vulns = check_path_vulnerability(path, uid);
            if (vulns) {
                has_vulns = 1;
                print_vulnerability(path, vulns);
            } else {
                printf("    " GREEN "OK" RESET " → %s\n", path);
            }
            path = strtok(NULL, ":");
        }
    } else {
        printf("\n" GREEN "[DT_RUNPATH]" RESET " Not set\n");
    }

    /* Show needed libraries */
    if (info.needed_count > 0) {
        printf("\n[NEEDED LIBRARIES] (%d total):\n", info.needed_count);
        for (int i = 0; i < info.needed_count && i < 10; i++) {
            printf("    • %s\n", info.needed_libs[i]);
        }
        if (info.needed_count > 10) {
            printf("    ... and %d more\n", info.needed_count - 10);
        }
    }

    /* Summary */
    printf("\n");
    if (has_vulns) {
        printf(RED "╔════════════════════════════════════════════════════════════════╗\n" RESET);
        printf(RED "║" RESET "  " RED "⚠ POTENTIALLY EXPLOITABLE RPATH/RUNPATH DETECTED!" RESET "          " RED "║\n" RESET);
        printf(RED "║" RESET "                                                               " RED "║\n" RESET);
        printf(RED "║" RESET "  An attacker who can write to the indicated paths may be      " RED "║\n" RESET);
        printf(RED "║" RESET "  able to hijack library loading and execute arbitrary code.   " RED "║\n" RESET);
        printf(RED "╚════════════════════════════════════════════════════════════════╝\n" RESET);
    } else {
        printf(GREEN "[✓] No obvious RPATH/RUNPATH vulnerabilities found.\n" RESET);
    }

    free_elf_info(&info);
}

/* ═══════════════════════════════════════════════════════════════════════════
 * SEARCH ORDER VISUALIZATION
 * ═══════════════════════════════════════════════════════════════════════════ */

void print_search_order(void) {
    printf("\n");
    printf(YELLOW "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf(YELLOW "  LIBRARY SEARCH ORDER (ld.so)\n" RESET);
    printf(YELLOW "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf("\n");
    printf("  ┌─────────────────────────────────────────────────────────────┐\n");
    printf("  │  1. " CYAN "DT_RPATH" RESET " (if DT_RUNPATH not set)                       │\n");
    printf("  │     └─ Embedded in binary, searched first                   │\n");
    printf("  │                                                             │\n");
    printf("  │  2. " CYAN "LD_LIBRARY_PATH" RESET " (environment variable)                 │\n");
    printf("  │     └─ User-controlled, ignored for SUID                    │\n");
    printf("  │                                                             │\n");
    printf("  │  3. " CYAN "DT_RUNPATH" RESET " (if set, DT_RPATH ignored)                  │\n");
    printf("  │     └─ Embedded in binary, searched after LD_LIBRARY_PATH   │\n");
    printf("  │                                                             │\n");
    printf("  │  4. " CYAN "/etc/ld.so.cache" RESET "                                       │\n");
    printf("  │     └─ Cached library paths from ldconfig                   │\n");
    printf("  │                                                             │\n");
    printf("  │  5. " CYAN "/lib, /usr/lib" RESET " (default paths)                         │\n");
    printf("  │     └─ Standard system library directories                  │\n");
    printf("  └─────────────────────────────────────────────────────────────┘\n");
    printf("\n");
    printf("  " RED "★" RESET " DT_RPATH is dangerous: searched BEFORE LD_LIBRARY_PATH!\n");
    printf("  " YELLOW "★" RESET " DT_RUNPATH is safer: searched AFTER LD_LIBRARY_PATH.\n");
    printf("  " CYAN "★" RESET " $ORIGIN expands to directory containing the executable.\n");
    printf("\n");
}

/* ═══════════════════════════════════════════════════════════════════════════
 * MAIN
 * ═══════════════════════════════════════════════════════════════════════════ */

int main(int argc, char *argv[]) {
    printf("\n");
    printf(CYAN "╔════════════════════════════════════════════════════════════════════╗\n" RESET);
    printf(CYAN "║" RESET "           DT_RPATH/DT_RUNPATH VULNERABILITY SCANNER               " CYAN "║\n" RESET);
    printf(CYAN "╚════════════════════════════════════════════════════════════════════╝\n" RESET);

    if (argc < 2) {
        printf("\nUsage: %s <binary> [binary2] ...\n", argv[0]);
        printf("       %s --search-order    Show library search order\n", argv[0]);
        printf("\nExamples:\n");
        printf("  %s ./vulnerable_app\n", argv[0]);
        printf("  %s /usr/bin/*\n", argv[0]);
        print_search_order();
        return 0;
    }

    if (strcmp(argv[1], "--search-order") == 0) {
        print_search_order();
        return 0;
    }

    for (int i = 1; i < argc; i++) {
        analyze_binary(argv[i]);
    }

    printf("\n");
    return 0;
}
