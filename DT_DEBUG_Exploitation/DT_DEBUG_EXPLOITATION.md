# Part 5: DT_DEBUG Exploitation - Accessing the Linker's Internal Structures

## Overview

DT_DEBUG is a special entry in the ELF dynamic section that points to the `r_debug` structure maintained by the dynamic linker (ld.so). This structure provides a **debugger interface** that exposes the complete list of loaded shared objects, their base addresses, and the linker's internal state.

While designed for debugging purposes, DT_DEBUG can be abused for:
- **ASLR bypass** - Finding library base addresses without leaks
- **Symbol resolution** - Finding functions without dlsym()
- **Library hiding** - Manipulating the link_map chain
- **Debugger detection** - Detecting if a program is being debugged
- **GOT discovery** - Finding GOT entries for hijacking

---

## The DT_DEBUG → r_debug → link_map Chain

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     DT_DEBUG STRUCTURE HIERARCHY                            │
└─────────────────────────────────────────────────────────────────────────────┘

    Program's .dynamic section
    ┌────────────────────────────┐
    │ DT_NEEDED: libc.so.6       │
    │ DT_NEEDED: libpthread.so.0 │
    │ DT_STRTAB: 0x...           │
    │ DT_SYMTAB: 0x...           │
    │ DT_DEBUG:  0x7f...  ───────┼────────────┐
    │ ...                        │            │
    └────────────────────────────┘            │
                                              ▼
                                    ┌─────────────────────┐
                                    │      r_debug        │
                                    ├─────────────────────┤
                                    │ r_version: 1        │
                                    │ r_map: ─────────────┼──────────┐
                                    │ r_brk: 0x7f...      │          │
                                    │ r_state: CONSISTENT │          │
                                    │ r_ldbase: 0x7f...   │          │
                                    └─────────────────────┘          │
                                                                     │
    ┌────────────────────────────────────────────────────────────────┘
    │
    ▼
  ┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
  │    link_map     │     │    link_map     │     │    link_map     │
  │   (main exe)    │     │   (libc.so)     │     │  (ld-linux.so)  │
  ├─────────────────┤     ├─────────────────┤     ├─────────────────┤
  │ l_addr: 0x...   │     │ l_addr: 0x7f... │     │ l_addr: 0x7f... │
  │ l_name: ""      │     │ l_name: "libc"  │     │ l_name: "ld"    │
  │ l_ld: 0x...     │     │ l_ld: 0x...     │     │ l_ld: 0x...     │
  │ l_next: ────────┼────→│ l_next: ────────┼────→│ l_next: NULL    │
  │ l_prev: NULL    │←────┼─ l_prev         │←────┼─ l_prev         │
  └─────────────────┘     └─────────────────┘     └─────────────────┘
```

---

## Key Structures

### r_debug Structure

```c
struct r_debug {
    int r_version;              /* Version number (usually 1) */
    struct link_map *r_map;     /* Head of loaded objects list */
    ElfW(Addr) r_brk;           /* Address of _dl_debug_state() */
    enum {
        RT_CONSISTENT,          /* Link_map is stable */
        RT_ADD,                 /* Library being added */
        RT_DELETE               /* Library being removed */
    } r_state;
    ElfW(Addr) r_ldbase;        /* Base address of ld.so */
};
```

### link_map Structure

```c
struct link_map {
    ElfW(Addr) l_addr;          /* Base address of shared object */
    char *l_name;               /* Absolute pathname */
    ElfW(Dyn) *l_ld;            /* .dynamic section pointer */
    struct link_map *l_next;    /* Next object in chain */
    struct link_map *l_prev;    /* Previous object in chain */
    /* ... additional fields ... */
};
```

---

## Finding DT_DEBUG

### Method 1: Via _DYNAMIC Symbol

```c
extern ElfW(Dyn) _DYNAMIC[];

struct r_debug *find_r_debug(void) {
    for (ElfW(Dyn) *dyn = _DYNAMIC; dyn->d_tag != DT_NULL; dyn++) {
        if (dyn->d_tag == DT_DEBUG) {
            return (struct r_debug *)dyn->d_un.d_ptr;
        }
    }
    return NULL;
}
```

### Method 2: Via Auxiliary Vector

```c
#include <sys/auxv.h>

/* AT_PHDR gives program headers, can find _DYNAMIC from there */
ElfW(Phdr) *phdr = (ElfW(Phdr) *)getauxval(AT_PHDR);
```

### Method 3: Via /proc/self/maps (for external analysis)

```bash
# Find the program's data segment, scan for DT_DEBUG entry
cat /proc/self/maps | grep "rw-p.*\[heap\]"
```

---

## Exploitation Technique 1: ASLR Bypass

With access to DT_DEBUG, you can find the base address of ANY loaded library:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           ASLR BYPASS VIA DT_DEBUG                          │
└─────────────────────────────────────────────────────────────────────────────┘

  Normal ASLR:
    libc.so loaded at random address each run
    0x7f1234560000 → 0x7f9876540000 → 0x7f5555550000

  With DT_DEBUG access:
    1. Find r_debug via DT_DEBUG
    2. Traverse r_map chain
    3. Find link_map for libc
    4. Read l_addr = EXACT BASE ADDRESS!

  Impact:
    ┌────────────────────────────────────────┐
    │  libc base:     0x7f1234560000        │
    │  system offset: 0x50d60 (constant!)    │
    │  system addr:   0x7f12345b0d60        │
    └────────────────────────────────────────┘

    Attacker now knows exactly where system() is!
```

### Code Example

```c
uintptr_t find_libc_base(void) {
    struct r_debug *debug = get_r_debug();
    for (struct link_map *lm = debug->r_map; lm; lm = lm->l_next) {
        if (strstr(lm->l_name, "libc")) {
            return lm->l_addr;  /* ASLR defeated! */
        }
    }
    return 0;
}
```

---

## Exploitation Technique 2: Symbol Resolution Without dlsym()

Using link_map's `l_ld` pointer, you can access any library's dynamic section and resolve symbols manually:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SYMBOL RESOLUTION WITHOUT DLSYM                          │
└─────────────────────────────────────────────────────────────────────────────┘

  r_debug → link_map (libc) → l_ld (.dynamic)
                                   │
                                   ▼
                    ┌──────────────────────────────┐
                    │ DT_SYMTAB → Symbol table     │
                    │ DT_STRTAB → String table     │
                    │ DT_HASH   → Symbol hash      │
                    └──────────────────────────────┘
                                   │
                                   ▼
                    Hash "system" → find symbol index
                                   │
                                   ▼
                    symtab[index].st_value + l_addr
                                   │
                                   ▼
                    ┌──────────────────────────────┐
                    │   system() address found!    │
                    │   No dlsym() needed!         │
                    └──────────────────────────────┘
```

### Why This Matters

- **Shellcode**: Can't call dlsym() easily from shellcode
- **Sandboxes**: Some sandboxes block dlsym()
- **Minimal footprint**: Avoid importing additional functions
- **Anti-analysis**: No obvious dlsym calls in code

---

## Exploitation Technique 3: Library Hiding

By manipulating the link_map chain, a library can be hidden from enumeration:

```
BEFORE HIDING:
  main ←→ libc ←→ evil.so ←→ ld.so
                     ↑
                  (visible)

AFTER HIDING:
  main ←→ libc ←──────────→ ld.so
                     ↑
              evil.so (orphaned but functional!)

  • dl_iterate_phdr() won't see evil.so
  • ldd won't show it
  • /proc/pid/maps via link_map won't show it
  • Debuggers using r_debug won't see it

  BUT: evil.so still works normally!
```

### Hiding Code

```c
void hide_library(struct link_map *target) {
    /* Unlink from doubly-linked list */
    if (target->l_prev) {
        target->l_prev->l_next = target->l_next;
    }
    if (target->l_next) {
        target->l_next->l_prev = target->l_prev;
    }
    /* Library is now invisible but still functional! */
}
```

---

## Exploitation Technique 4: Debugger Detection

The r_debug structure reveals debugging activity:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      DEBUGGER DETECTION METHODS                             │
└─────────────────────────────────────────────────────────────────────────────┘

  METHOD 1: Check r_brk for breakpoints
  ─────────────────────────────────────
    r_brk points to _dl_debug_state()
    Debuggers set breakpoints here!

    if (*(uint8_t *)debug->r_brk == 0xCC) {
        /* INT3 instruction = breakpoint! */
        printf("DEBUGGER DETECTED!\n");
    }

  METHOD 2: Monitor r_state
  ─────────────────────────────────────
    RT_CONSISTENT = normal
    RT_ADD/RT_DELETE = library change in progress

    Persistent RT_ADD = suspicious (debugger holding state)

  METHOD 3: r_brk address validation
  ─────────────────────────────────────
    Compare r_brk with expected ld.so location
    Unexpected address = potential hook/tampering
```

---

## Comparison with Other Techniques

| Technique | What You Get | Requires |
|-----------|-------------|----------|
| **DT_DEBUG** | All library bases, symbols, GOT | Read access to memory |
| **LD_PRELOAD** | Hook any function | Control of environment |
| **GOT Hijacking** | Redirect specific calls | Write to GOT |
| **RPATH** | Load malicious library | Write to RPATH directory |
| **/proc/pid/maps** | Memory layout | Read /proc filesystem |

### DT_DEBUG Advantages

1. **No writes needed** - Pure information disclosure
2. **Works from within process** - Useful in shellcode
3. **Reliable** - Structure is stable across glibc versions
4. **Complete** - Exposes ALL loaded libraries
5. **Dynamic section access** - Find GOT, PLT, symbols for any library

---

## Defense Considerations

### For Defenders

1. **Stripping DT_DEBUG** (not recommended for production)
   ```bash
   # Remove debug info
   strip --strip-debug binary
   # Note: DT_DEBUG is still present, just less useful
   ```

2. **Runtime integrity checking**
   ```c
   /* Periodically verify link_map chain */
   int expected_libs = get_expected_library_count();
   int actual_libs = count_link_map_entries();
   if (actual_libs != expected_libs) {
       alert("Link_map tampering detected!");
   }
   ```

3. **r_brk monitoring**
   ```c
   /* Check if _dl_debug_state has been hooked */
   void *expected_r_brk = calculate_expected_r_brk();
   if (debug->r_brk != expected_r_brk) {
       alert("r_brk has been modified!");
   }
   ```

### Why DT_DEBUG Can't Be Removed

- Required for debuggers (GDB, LLDB) to work
- Required for dlopen() to function properly
- Removing it breaks many development tools
- Part of the ELF/glibc ABI

---

## Real-World Applications

### 1. Exploit Development
- Find libc gadgets for ROP chains
- Calculate offsets dynamically
- Build reliable shellcode

### 2. Malware
- Hide injected libraries
- Detect analysis environments
- Anti-debugging

### 3. Security Research
- Process memory forensics
- Library injection detection
- Runtime analysis tools

### 4. Debugging Tools
- GDB uses DT_DEBUG for library tracking
- Valgrind uses it for memory analysis
- Sanitizers use it for coverage

---

## Files in This POC

| File | Description |
|------|-------------|
| `dt_debug_explorer.c` | Explore r_debug and link_map structures |
| `got_resolver.c` | Resolve symbols without dlsym() |
| `linkmap_abuse.c` | Library hiding and debugger detection |
| `Makefile` | Build and run demonstrations |

## Building and Running

```bash
# Build all components
make all

# Run all demonstrations
make demo

# Individual demonstrations
make explore   # DT_DEBUG structure exploration
make resolve   # Symbol resolution without dlsym
make abuse     # Link_map manipulation

# Test debugger detection under GDB
make debug-test

# Clean up
make clean
```

---

## Key Takeaways

1. **DT_DEBUG provides a window into the linker** - Access to all loaded libraries and their metadata

2. **ASLR is defeated with arbitrary read** - link_map contains base addresses of all libraries

3. **Symbols can be resolved without dlsym()** - Useful for shellcode and avoiding detection

4. **Libraries can be hidden** - Unlinking from link_map makes libraries invisible to enumeration

5. **Debugger detection is possible** - r_brk and r_state reveal debugging activity

6. **This is fundamental to ELF** - Can't be disabled without breaking debuggers and dynamic loading
