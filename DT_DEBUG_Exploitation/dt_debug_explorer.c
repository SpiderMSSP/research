/*
 * dt_debug_explorer.c - DT_DEBUG Structure Explorer
 *
 * This tool demonstrates how to use DT_DEBUG to:
 *   1. Find the r_debug structure maintained by ld.so
 *   2. Traverse the link_map chain of all loaded libraries
 *   3. Extract base addresses (ASLR bypass)
 *   4. Find GOT/PLT addresses without symbols
 *   5. Detect the dynamic linker state
 *
 * The DT_DEBUG entry in the dynamic section points to r_debug,
 * which is the debugger interface maintained by the dynamic linker.
 *
 * Compile: gcc -o dt_debug_explorer dt_debug_explorer.c -ldl
 *
 * EDUCATIONAL PURPOSES ONLY
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <link.h>
#include <elf.h>
#include <dlfcn.h>
#include <sys/auxv.h>

/* Color codes */
#define RED     "\033[1;31m"
#define GREEN   "\033[1;32m"
#define YELLOW  "\033[1;33m"
#define BLUE    "\033[1;34m"
#define MAGENTA "\033[1;35m"
#define CYAN    "\033[1;36m"
#define RESET   "\033[0m"

/* ═══════════════════════════════════════════════════════════════════════════
 * STRUCTURE DEFINITIONS (from link.h, shown here for clarity)
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * struct r_debug {
 *     int r_version;           // Version number for this protocol
 *     struct link_map *r_map;  // Head of the chain of loaded objects
 *     ElfW(Addr) r_brk;        // Address of _dl_debug_state()
 *     enum { RT_CONSISTENT, RT_ADD, RT_DELETE } r_state;
 *     ElfW(Addr) r_ldbase;     // Base address of ld.so
 * };
 *
 * struct link_map {
 *     ElfW(Addr) l_addr;       // Base address of the shared object
 *     char *l_name;            // Absolute file name
 *     ElfW(Dyn) *l_ld;         // Dynamic section pointer
 *     struct link_map *l_next; // Next link_map
 *     struct link_map *l_prev; // Previous link_map
 * };
 */

/* ═══════════════════════════════════════════════════════════════════════════
 * METHOD 1: Find DT_DEBUG via the auxiliary vector
 * ═══════════════════════════════════════════════════════════════════════════ */

struct r_debug *find_r_debug_via_auxv(void) {
    /* AT_BASE contains the base address of the interpreter (ld.so) */
    /* But we need to find the actual r_debug structure */

    /* The _DYNAMIC symbol points to our program's dynamic section */
    extern ElfW(Dyn) _DYNAMIC[];

    for (ElfW(Dyn) *dyn = _DYNAMIC; dyn->d_tag != DT_NULL; dyn++) {
        if (dyn->d_tag == DT_DEBUG) {
            return (struct r_debug *)dyn->d_un.d_ptr;
        }
    }

    return NULL;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * METHOD 2: Find DT_DEBUG by parsing /proc/self/exe
 * ═══════════════════════════════════════════════════════════════════════════ */

struct r_debug *find_r_debug_via_maps(void) {
    FILE *maps = fopen("/proc/self/maps", "r");
    if (!maps) return NULL;

    char line[512];
    uintptr_t base = 0;

    /* Find our executable's base address */
    while (fgets(line, sizeof(line), maps)) {
        if (strstr(line, "r-xp") && strstr(line, "dt_debug")) {
            sscanf(line, "%lx-", &base);
            break;
        }
    }
    fclose(maps);

    if (!base) return NULL;

    /* Parse our own ELF headers to find _DYNAMIC */
    Elf64_Ehdr *ehdr = (Elf64_Ehdr *)base;
    Elf64_Phdr *phdr = (Elf64_Phdr *)(base + ehdr->e_phoff);

    for (int i = 0; i < ehdr->e_phnum; i++) {
        if (phdr[i].p_type == PT_DYNAMIC) {
            Elf64_Dyn *dyn = (Elf64_Dyn *)(base + phdr[i].p_vaddr);
            while (dyn->d_tag != DT_NULL) {
                if (dyn->d_tag == DT_DEBUG) {
                    return (struct r_debug *)dyn->d_un.d_ptr;
                }
                dyn++;
            }
        }
    }

    return NULL;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * LINK_MAP TRAVERSAL
 * ═══════════════════════════════════════════════════════════════════════════ */

void print_link_map_chain(struct r_debug *debug) {
    if (!debug || !debug->r_map) {
        printf(RED "[!] No link_map available\n" RESET);
        return;
    }

    printf("\n");
    printf(YELLOW "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf(YELLOW "  LINK_MAP CHAIN (All Loaded Shared Objects)\n" RESET);
    printf(YELLOW "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf("\n");

    int index = 0;
    for (struct link_map *lm = debug->r_map; lm != NULL; lm = lm->l_next) {
        const char *name = lm->l_name;
        if (!name || name[0] == '\0') {
            name = "(main executable)";
        }

        printf("  [%2d] " CYAN "link_map @ %p" RESET "\n", index, (void *)lm);
        printf("       ├─ l_addr (base):  " GREEN "0x%016lx" RESET "\n", lm->l_addr);
        printf("       ├─ l_name:         %s\n", name);
        printf("       ├─ l_ld (dynamic): " BLUE "0x%016lx" RESET "\n", (uintptr_t)lm->l_ld);
        printf("       ├─ l_next:         %p\n", (void *)lm->l_next);
        printf("       └─ l_prev:         %p\n", (void *)lm->l_prev);
        printf("\n");

        index++;
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * ASLR BYPASS - Find libc base address
 * ═══════════════════════════════════════════════════════════════════════════ */

uintptr_t find_library_base(struct r_debug *debug, const char *lib_name) {
    if (!debug || !debug->r_map) return 0;

    for (struct link_map *lm = debug->r_map; lm != NULL; lm = lm->l_next) {
        if (lm->l_name && strstr(lm->l_name, lib_name)) {
            return lm->l_addr;
        }
    }
    return 0;
}

void demonstrate_aslr_bypass(struct r_debug *debug) {
    printf("\n");
    printf(RED "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf(RED "  ASLR BYPASS DEMONSTRATION\n" RESET);
    printf(RED "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf("\n");
    printf("  Using DT_DEBUG → r_debug → link_map chain, we can find\n");
    printf("  the base addresses of ALL loaded libraries, defeating ASLR!\n\n");

    /* Find libc */
    uintptr_t libc_base = find_library_base(debug, "libc");
    if (libc_base) {
        printf("  " GREEN "★" RESET " libc base address: " RED "0x%016lx" RESET "\n", libc_base);

        /* Calculate system() offset (example) */
        void *system_addr = dlsym(RTLD_NEXT, "system");
        if (system_addr) {
            uintptr_t system_offset = (uintptr_t)system_addr - libc_base;
            printf("  " GREEN "★" RESET " system() address:  " RED "0x%016lx" RESET "\n", (uintptr_t)system_addr);
            printf("  " GREEN "★" RESET " system() offset:   " YELLOW "0x%lx" RESET " (constant across ASLR)\n", system_offset);
        }
    }

    /* Find ld.so */
    uintptr_t ld_base = find_library_base(debug, "ld-linux");
    if (!ld_base) ld_base = find_library_base(debug, "ld-musl");
    if (ld_base) {
        printf("  " GREEN "★" RESET " ld.so base address: " RED "0x%016lx" RESET "\n", ld_base);
    }

    printf("\n");
    printf("  " YELLOW "Impact:" RESET " Attacker with arbitrary read can use DT_DEBUG to\n");
    printf("          find all library addresses without any leaks!\n");
}

/* ═══════════════════════════════════════════════════════════════════════════
 * FIND DYNAMIC SECTION ENTRIES FOR A LIBRARY
 * ═══════════════════════════════════════════════════════════════════════════ */

void analyze_library_dynamic(struct link_map *lm) {
    if (!lm || !lm->l_ld) return;

    const char *name = lm->l_name;
    if (!name || name[0] == '\0') name = "(main executable)";

    printf("\n");
    printf(CYAN "───────────────────────────────────────────────────────────────────\n" RESET);
    printf(CYAN "  DYNAMIC SECTION: %s\n" RESET, name);
    printf(CYAN "───────────────────────────────────────────────────────────────────\n" RESET);
    printf("\n");

    uintptr_t got_plt = 0, plt_got = 0, strtab = 0, symtab = 0;
    uintptr_t jmprel = 0, init = 0, fini = 0;

    for (ElfW(Dyn) *dyn = lm->l_ld; dyn->d_tag != DT_NULL; dyn++) {
        switch (dyn->d_tag) {
            case DT_PLTGOT:
                got_plt = dyn->d_un.d_ptr;
                printf("  DT_PLTGOT  (GOT):      " GREEN "0x%016lx" RESET "\n", got_plt);
                break;
            case DT_STRTAB:
                strtab = dyn->d_un.d_ptr;
                printf("  DT_STRTAB  (strings):  0x%016lx\n", strtab);
                break;
            case DT_SYMTAB:
                symtab = dyn->d_un.d_ptr;
                printf("  DT_SYMTAB  (symbols):  0x%016lx\n", symtab);
                break;
            case DT_JMPREL:
                jmprel = dyn->d_un.d_ptr;
                printf("  DT_JMPREL  (PLT rel):  0x%016lx\n", jmprel);
                break;
            case DT_INIT:
                init = dyn->d_un.d_ptr;
                printf("  DT_INIT    (init):     " MAGENTA "0x%016lx" RESET "\n", lm->l_addr + init);
                break;
            case DT_FINI:
                fini = dyn->d_un.d_ptr;
                printf("  DT_FINI    (fini):     " MAGENTA "0x%016lx" RESET "\n", lm->l_addr + fini);
                break;
        }
    }

    if (got_plt) {
        printf("\n  " RED "★ GOT address found!" RESET " An attacker could:\n");
        printf("    • Read GOT entries to leak libc addresses\n");
        printf("    • Overwrite GOT entries to hijack function calls\n");
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * R_DEBUG STATE ANALYSIS
 * ═══════════════════════════════════════════════════════════════════════════ */

void analyze_r_debug_state(struct r_debug *debug) {
    printf("\n");
    printf(YELLOW "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf(YELLOW "  R_DEBUG STRUCTURE ANALYSIS\n" RESET);
    printf(YELLOW "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf("\n");

    printf("  r_debug @ " CYAN "%p" RESET "\n", (void *)debug);
    printf("  ├─ r_version: %d\n", debug->r_version);
    printf("  ├─ r_map:     %p (head of link_map chain)\n", (void *)debug->r_map);
    printf("  ├─ r_brk:     " MAGENTA "0x%016lx" RESET " (_dl_debug_state)\n", (ElfW(Addr))debug->r_brk);
    printf("  ├─ r_state:   ");

    switch (debug->r_state) {
        case RT_CONSISTENT:
            printf(GREEN "RT_CONSISTENT" RESET " (link_map is stable)\n");
            break;
        case RT_ADD:
            printf(YELLOW "RT_ADD" RESET " (library being added)\n");
            break;
        case RT_DELETE:
            printf(YELLOW "RT_DELETE" RESET " (library being removed)\n");
            break;
        default:
            printf(RED "UNKNOWN (%d)" RESET "\n", debug->r_state);
    }

    printf("  └─ r_ldbase:  " GREEN "0x%016lx" RESET " (ld.so base address)\n", (ElfW(Addr))debug->r_ldbase);

    printf("\n");
    printf("  " YELLOW "Key insight:" RESET " r_brk points to _dl_debug_state(), which is\n");
    printf("  called whenever the link_map changes. Debuggers set a\n");
    printf("  breakpoint here to track library loading!\n");
}

/* ═══════════════════════════════════════════════════════════════════════════
 * VISUALIZATION
 * ═══════════════════════════════════════════════════════════════════════════ */

void print_structure_diagram(void) {
    printf("\n");
    printf(YELLOW "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf(YELLOW "  DT_DEBUG STRUCTURE RELATIONSHIPS\n" RESET);
    printf(YELLOW "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf("\n");
    printf("    Program's .dynamic section\n");
    printf("    ┌────────────────────────┐\n");
    printf("    │ DT_NEEDED: libc.so     │\n");
    printf("    │ DT_NEEDED: libm.so     │\n");
    printf("    │ DT_STRTAB: 0x...       │\n");
    printf("    │ DT_SYMTAB: 0x...       │\n");
    printf("    │ " RED "DT_DEBUG: 0x..." RESET "       │────┐\n");
    printf("    │ ...                    │    │\n");
    printf("    └────────────────────────┘    │\n");
    printf("                                  │\n");
    printf("                                  ▼\n");
    printf("                         ┌─────────────────┐\n");
    printf("                         │    " CYAN "r_debug" RESET "      │\n");
    printf("                         ├─────────────────┤\n");
    printf("                         │ r_version       │\n");
    printf("                         │ r_map ──────────┼────┐\n");
    printf("                         │ r_brk (debug)   │    │\n");
    printf("                         │ r_state         │    │\n");
    printf("                         │ r_ldbase        │    │\n");
    printf("                         └─────────────────┘    │\n");
    printf("                                                │\n");
    printf("    ┌───────────────────────────────────────────┘\n");
    printf("    ▼\n");
    printf("  ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐\n");
    printf("  │   " GREEN "link_map" RESET "      │──→│   " GREEN "link_map" RESET "      │──→│   " GREEN "link_map" RESET "      │──→ NULL\n");
    printf("  ├─────────────────┤   ├─────────────────┤   ├─────────────────┤\n");
    printf("  │ l_addr (base)   │   │ l_addr (base)   │   │ l_addr (base)   │\n");
    printf("  │ l_name          │   │ l_name          │   │ l_name          │\n");
    printf("  │ l_ld (.dynamic) │   │ l_ld (.dynamic) │   │ l_ld (.dynamic) │\n");
    printf("  │ l_next ─────────┼──→│ l_next ─────────┼──→│ l_next ─────────┼──→ NULL\n");
    printf("  │ l_prev          │←──┼─ l_prev         │←──┼─ l_prev         │\n");
    printf("  └─────────────────┘   └─────────────────┘   └─────────────────┘\n");
    printf("       (main)              (libc.so)            (ld-linux.so)\n");
    printf("\n");
}

/* ═══════════════════════════════════════════════════════════════════════════
 * MAIN
 * ═══════════════════════════════════════════════════════════════════════════ */

int main(void) {
    printf("\n");
    printf(RED "╔════════════════════════════════════════════════════════════════════╗\n" RESET);
    printf(RED "║" YELLOW "              DT_DEBUG EXPLOITATION EXPLORER                        " RED "║\n" RESET);
    printf(RED "║" RESET "                                                                    " RED "║\n" RESET);
    printf(RED "║" RESET "  Demonstrating how DT_DEBUG provides access to internal linker     " RED "║\n" RESET);
    printf(RED "║" RESET "  structures that can be abused for ASLR bypass and more            " RED "║\n" RESET);
    printf(RED "╚════════════════════════════════════════════════════════════════════╝\n" RESET);

    /* Print the structure diagram first */
    print_structure_diagram();

    /* Find r_debug via _DYNAMIC */
    struct r_debug *debug = find_r_debug_via_auxv();

    if (!debug) {
        printf(RED "[!] Could not find r_debug structure\n" RESET);
        return 1;
    }

    printf(GREEN "[✓] Found r_debug @ %p\n" RESET, (void *)debug);

    /* Analyze r_debug */
    analyze_r_debug_state(debug);

    /* Print link_map chain */
    print_link_map_chain(debug);

    /* Demonstrate ASLR bypass */
    demonstrate_aslr_bypass(debug);

    /* Analyze main executable's dynamic section */
    if (debug->r_map) {
        analyze_library_dynamic(debug->r_map);

        /* Also analyze libc */
        for (struct link_map *lm = debug->r_map; lm != NULL; lm = lm->l_next) {
            if (lm->l_name && strstr(lm->l_name, "libc")) {
                analyze_library_dynamic(lm);
                break;
            }
        }
    }

    printf("\n");
    printf(GREEN "[✓] DT_DEBUG exploration complete.\n" RESET);
    printf("\n");

    return 0;
}
