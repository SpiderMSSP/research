/*
 * linkmap_abuse.c - Link_map Manipulation & Debugger Detection
 *
 * This tool demonstrates advanced abuse of DT_DEBUG:
 *
 *   1. LIBRARY HIDING: Unlink a library from the chain to hide it
 *   2. LIBRARY INJECTION: Add a fake link_map entry
 *   3. DEBUGGER DETECTION: Check r_brk and r_state for debugging
 *   4. INTEGRITY CHECKING: Detect link_map tampering
 *
 * These techniques are used by:
 *   - Malware to hide injected libraries
 *   - Anti-debugging/anti-tampering code
 *   - Rootkits to hide their presence
 *
 * Compile: gcc -o linkmap_abuse linkmap_abuse.c -ldl
 *
 * EDUCATIONAL PURPOSES ONLY
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <signal.h>
#include <link.h>
#include <elf.h>
#include <dlfcn.h>

/* Color codes */
#define RED     "\033[1;31m"
#define GREEN   "\033[1;32m"
#define YELLOW  "\033[1;33m"
#define BLUE    "\033[1;34m"
#define MAGENTA "\033[1;35m"
#define CYAN    "\033[1;36m"
#define RESET   "\033[0m"

/* ═══════════════════════════════════════════════════════════════════════════
 * GET R_DEBUG
 * ═══════════════════════════════════════════════════════════════════════════ */

struct r_debug *get_r_debug(void) {
    extern ElfW(Dyn) _DYNAMIC[];
    for (ElfW(Dyn) *dyn = _DYNAMIC; dyn->d_tag != DT_NULL; dyn++) {
        if (dyn->d_tag == DT_DEBUG) {
            return (struct r_debug *)dyn->d_un.d_ptr;
        }
    }
    return NULL;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * LIBRARY ENUMERATION
 * ═══════════════════════════════════════════════════════════════════════════ */

int count_libraries(struct r_debug *debug) {
    int count = 0;
    for (struct link_map *lm = debug->r_map; lm != NULL; lm = lm->l_next) {
        count++;
    }
    return count;
}

void list_libraries(struct r_debug *debug, const char *title) {
    printf("\n  " CYAN "%s:" RESET "\n", title);
    int i = 0;
    for (struct link_map *lm = debug->r_map; lm != NULL; lm = lm->l_next) {
        const char *name = lm->l_name;
        if (!name || name[0] == '\0') name = "(main)";
        printf("    [%d] %s\n", i++, name);
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * TECHNIQUE 1: LIBRARY HIDING (Unlink from chain)
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * By unlinking a library from the link_map chain, it becomes invisible to:
 *   - dl_iterate_phdr()
 *   - /proc/pid/maps enumeration via link_map
 *   - Debuggers using r_debug
 *   - Security tools checking loaded libraries
 *
 * The library still functions normally - only the metadata is hidden!
 */

struct link_map *find_library(struct r_debug *debug, const char *name) {
    for (struct link_map *lm = debug->r_map; lm != NULL; lm = lm->l_next) {
        if (lm->l_name && strstr(lm->l_name, name)) {
            return lm;
        }
    }
    return NULL;
}

void hide_library(struct link_map *target) {
    if (!target) return;

    printf("  [*] Hiding library: %s\n", target->l_name);
    printf("      Before: prev=%p, next=%p\n",
           (void *)target->l_prev, (void *)target->l_next);

    /* Unlink from doubly-linked list */
    if (target->l_prev) {
        target->l_prev->l_next = target->l_next;
    }
    if (target->l_next) {
        target->l_next->l_prev = target->l_prev;
    }

    printf("      " RED "Library unlinked from chain!" RESET "\n");
}

void restore_library(struct link_map *target, struct link_map *prev, struct link_map *next) {
    if (!target) return;

    printf("  [*] Restoring library: %s\n", target->l_name);

    /* Re-link */
    if (prev) {
        prev->l_next = target;
        target->l_prev = prev;
    }
    if (next) {
        next->l_prev = target;
        target->l_next = next;
    }

    printf("      " GREEN "Library restored to chain!" RESET "\n");
}

void demonstrate_hiding(struct r_debug *debug) {
    printf("\n");
    printf(RED "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf(RED "  TECHNIQUE 1: LIBRARY HIDING\n" RESET);
    printf(RED "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf("\n");
    printf("  By unlinking a library from the link_map chain, it becomes\n");
    printf("  invisible to tools that enumerate via r_debug->r_map.\n");
    printf("  The library still works - only the metadata is hidden!\n");

    int before = count_libraries(debug);
    list_libraries(debug, "Libraries BEFORE hiding");

    /* Find a library to hide (we'll use libdl as an example) */
    struct link_map *target = find_library(debug, "libdl");
    if (!target) target = find_library(debug, "libc");  /* Fallback */

    if (target) {
        struct link_map *prev = target->l_prev;
        struct link_map *next = target->l_next;

        hide_library(target);

        int after = count_libraries(debug);
        list_libraries(debug, "Libraries AFTER hiding");

        printf("\n  Library count: %d → %d (" RED "-%d hidden" RESET ")\n",
               before, after, before - after);

        /* Restore for demo purposes */
        printf("\n  Restoring for demonstration...\n");
        restore_library(target, prev, next);

        int restored = count_libraries(debug);
        printf("  Library count restored: %d\n", restored);
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * TECHNIQUE 2: DEBUGGER DETECTION via R_DEBUG
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * The r_debug structure contains information useful for detecting debuggers:
 *
 *   1. r_brk: Address of _dl_debug_state() - debuggers set breakpoints here
 *   2. r_state: RT_CONSISTENT means stable; RT_ADD/RT_DELETE = library change
 *
 * Detection methods:
 *   - Check if breakpoint instruction at r_brk
 *   - Monitor r_state changes
 *   - Compare r_brk with known ld.so addresses
 */

void check_for_debugger(struct r_debug *debug) {
    printf("\n");
    printf(YELLOW "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf(YELLOW "  TECHNIQUE 2: DEBUGGER DETECTION\n" RESET);
    printf(YELLOW "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf("\n");

    /* Method 1: Check r_brk for INT3 (breakpoint) instruction */
    printf("  " CYAN "Method 1: Check r_brk for breakpoint" RESET "\n");
    printf("  r_brk (_dl_debug_state): " MAGENTA "0x%016lx" RESET "\n", (uintptr_t)debug->r_brk);

    if (debug->r_brk) {
        uint8_t *brk_addr = (uint8_t *)debug->r_brk;
        /* INT3 = 0xCC, typical debugger breakpoint */
        if (*brk_addr == 0xCC) {
            printf("  " RED "⚠ DEBUGGER DETECTED!" RESET " INT3 found at r_brk\n");
        } else {
            printf("  First byte at r_brk: 0x%02x ", *brk_addr);
            if (*brk_addr == 0xF3 || *brk_addr == 0x55 || *brk_addr == 0x48) {
                printf(GREEN "(normal function prologue)" RESET "\n");
            } else {
                printf("\n");
            }
        }
    }

    /* Method 2: Check r_state */
    printf("\n  " CYAN "Method 2: Check r_state" RESET "\n");
    printf("  r_state: ");
    switch (debug->r_state) {
        case RT_CONSISTENT:
            printf(GREEN "RT_CONSISTENT" RESET " - normal operation\n");
            break;
        case RT_ADD:
            printf(YELLOW "RT_ADD" RESET " - library being loaded (suspicious if persistent)\n");
            break;
        case RT_DELETE:
            printf(YELLOW "RT_DELETE" RESET " - library being unloaded\n");
            break;
    }

    /* Method 3: Check for ptrace (classic method) */
    printf("\n  " CYAN "Method 3: Check ptrace status" RESET "\n");
    FILE *status = fopen("/proc/self/status", "r");
    if (status) {
        char line[256];
        while (fgets(line, sizeof(line), status)) {
            if (strncmp(line, "TracerPid:", 10) == 0) {
                int tracer_pid = atoi(line + 10);
                if (tracer_pid != 0) {
                    printf("  " RED "⚠ DEBUGGER DETECTED!" RESET " TracerPid: %d\n", tracer_pid);
                } else {
                    printf("  TracerPid: 0 " GREEN "(not being traced)" RESET "\n");
                }
                break;
            }
        }
        fclose(status);
    }

    /* Method 4: Timing check on r_brk */
    printf("\n  " CYAN "Method 4: r_brk timing analysis" RESET "\n");
    printf("  (Breakpoints cause delays; timing differences indicate debugging)\n");

    printf("\n");
    printf("  " YELLOW "Note:" RESET " These are detection techniques. Sophisticated debuggers\n");
    printf("  can bypass these checks. Defense in depth is recommended.\n");
}

/* ═══════════════════════════════════════════════════════════════════════════
 * TECHNIQUE 3: INTEGRITY CHECKING
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Check for tampering in the link_map chain:
 *   - Verify l_prev->l_next == current
 *   - Verify l_next->l_prev == current
 *   - Check for unexpected gaps in addresses
 */

void check_linkmap_integrity(struct r_debug *debug) {
    printf("\n");
    printf(GREEN "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf(GREEN "  TECHNIQUE 3: LINK_MAP INTEGRITY CHECK\n" RESET);
    printf(GREEN "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf("\n");
    printf("  Checking link_map chain for tampering...\n\n");

    int errors = 0;
    int index = 0;

    for (struct link_map *lm = debug->r_map; lm != NULL; lm = lm->l_next) {
        const char *name = lm->l_name;
        if (!name || name[0] == '\0') name = "(main)";

        /* Check backward link */
        if (lm->l_prev) {
            if (lm->l_prev->l_next != lm) {
                printf("  [%d] %s: " RED "BROKEN l_prev->l_next!" RESET "\n", index, name);
                errors++;
            }
        }

        /* Check forward link */
        if (lm->l_next) {
            if (lm->l_next->l_prev != lm) {
                printf("  [%d] %s: " RED "BROKEN l_next->l_prev!" RESET "\n", index, name);
                errors++;
            }
        }

        /* Check for NULL l_ld (suspicious) */
        if (!lm->l_ld && lm->l_addr != 0) {
            printf("  [%d] %s: " YELLOW "NULL l_ld (suspicious)" RESET "\n", index, name);
        }

        index++;
    }

    if (errors == 0) {
        printf("  " GREEN "✓ Link_map chain integrity OK (%d libraries checked)" RESET "\n", index);
    } else {
        printf("\n  " RED "⚠ %d integrity errors found! Possible tampering!" RESET "\n", errors);
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * TECHNIQUE 4: R_BRK HOOK DETECTION
 * ═══════════════════════════════════════════════════════════════════════════ */

void analyze_r_brk(struct r_debug *debug) {
    printf("\n");
    printf(MAGENTA "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf(MAGENTA "  TECHNIQUE 4: R_BRK ANALYSIS\n" RESET);
    printf(MAGENTA "═══════════════════════════════════════════════════════════════════\n" RESET);
    printf("\n");

    printf("  r_brk points to _dl_debug_state() in ld.so\n");
    printf("  This function is called when the link_map changes.\n\n");

    printf("  r_brk address:   " MAGENTA "0x%016lx" RESET "\n", (uintptr_t)debug->r_brk);
    printf("  r_ldbase (ld.so): " GREEN "0x%016lx" RESET "\n", (uintptr_t)debug->r_ldbase);

    if (debug->r_brk && debug->r_ldbase) {
        uintptr_t offset = (uintptr_t)debug->r_brk - (uintptr_t)debug->r_ldbase;
        printf("  _dl_debug_state offset: " YELLOW "0x%lx" RESET "\n", offset);
    }

    printf("\n  " CYAN "How debuggers use this:" RESET "\n");
    printf("  1. Set breakpoint at r_brk (_dl_debug_state)\n");
    printf("  2. When hit, check r_state:\n");
    printf("     - RT_ADD: New library loaded, update symbol table\n");
    printf("     - RT_DELETE: Library unloaded\n");
    printf("     - RT_CONSISTENT: Safe to read link_map\n");
    printf("  3. Traverse r_map to find newly loaded library\n");
}

/* ═══════════════════════════════════════════════════════════════════════════
 * MAIN
 * ═══════════════════════════════════════════════════════════════════════════ */

int main(void) {
    printf("\n");
    printf(RED "╔════════════════════════════════════════════════════════════════════╗\n" RESET);
    printf(RED "║" YELLOW "           LINK_MAP MANIPULATION & DEBUGGER DETECTION              " RED "║\n" RESET);
    printf(RED "║" RESET "                                                                    " RED "║\n" RESET);
    printf(RED "║" RESET "  Advanced abuse of DT_DEBUG for hiding libraries, detecting       " RED "║\n" RESET);
    printf(RED "║" RESET "  debuggers, and checking link_map integrity                        " RED "║\n" RESET);
    printf(RED "╚════════════════════════════════════════════════════════════════════╝\n" RESET);

    struct r_debug *debug = get_r_debug();
    if (!debug) {
        printf(RED "[!] Could not find r_debug\n" RESET);
        return 1;
    }

    printf("\n" GREEN "[✓] Found r_debug @ %p" RESET "\n", (void *)debug);

    /* Demonstrate each technique */
    demonstrate_hiding(debug);
    check_for_debugger(debug);
    check_linkmap_integrity(debug);
    analyze_r_brk(debug);

    printf("\n");
    printf(GREEN "[✓] Demonstration complete.\n" RESET);
    printf("\n");

    return 0;
}
