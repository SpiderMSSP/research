/*
 * got_resolver.c - GOT Resolution via DT_DEBUG
 *
 * This tool demonstrates how to:
 *   1. Find function addresses without using dlsym()
 *   2. Resolve symbols by parsing the dynamic section via DT_DEBUG
 *   3. Find GOT entries for any function
 *   4. Calculate offsets for exploitation
 *
 * This technique is useful when:
 *   - dlsym is not available or blocked
 *   - You have arbitrary read but limited execution
 *   - Building shellcode that needs to find libc functions
 *
 * Compile: gcc -o got_resolver got_resolver.c
 *
 * EDUCATIONAL PURPOSES ONLY
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <link.h>
#include <elf.h>

/* Color codes */
#define RED     "\033[1;31m"
#define GREEN   "\033[1;32m"
#define YELLOW  "\033[1;33m"
#define BLUE    "\033[1;34m"
#define MAGENTA "\033[1;35m"
#define CYAN    "\033[1;36m"
#define RESET   "\033[0m"

/* ═══════════════════════════════════════════════════════════════════════════
 * DYNAMIC SECTION PARSER
 * ═══════════════════════════════════════════════════════════════════════════ */

typedef struct {
    ElfW(Sym) *symtab;
    char *strtab;
    size_t strtab_size;
    ElfW(Word) *hash;
    ElfW(Addr) *pltgot;
    ElfW(Rela) *jmprel;
    size_t pltrelsz;
    uintptr_t base;
} dyn_info_t;

int parse_dynamic_section(struct link_map *lm, dyn_info_t *info) {
    if (!lm || !lm->l_ld) return -1;

    memset(info, 0, sizeof(*info));
    info->base = lm->l_addr;

    for (ElfW(Dyn) *dyn = lm->l_ld; dyn->d_tag != DT_NULL; dyn++) {
        switch (dyn->d_tag) {
            case DT_SYMTAB:
                info->symtab = (ElfW(Sym) *)dyn->d_un.d_ptr;
                break;
            case DT_STRTAB:
                info->strtab = (char *)dyn->d_un.d_ptr;
                break;
            case DT_STRSZ:
                info->strtab_size = dyn->d_un.d_val;
                break;
            case DT_HASH:
                info->hash = (ElfW(Word) *)dyn->d_un.d_ptr;
                break;
            case DT_PLTGOT:
                info->pltgot = (ElfW(Addr) *)dyn->d_un.d_ptr;
                break;
            case DT_JMPREL:
                info->jmprel = (ElfW(Rela) *)dyn->d_un.d_ptr;
                break;
            case DT_PLTRELSZ:
                info->pltrelsz = dyn->d_un.d_val;
                break;
        }
    }

    return (info->symtab && info->strtab) ? 0 : -1;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * SYMBOL RESOLUTION (without dlsym!)
 * ═══════════════════════════════════════════════════════════════════════════ */

/* ELF hash function */
static unsigned long elf_hash(const char *name) {
    unsigned long h = 0, g;
    while (*name) {
        h = (h << 4) + *name++;
        if ((g = h & 0xf0000000))
            h ^= g >> 24;
        h &= ~g;
    }
    return h;
}

void *resolve_symbol(dyn_info_t *info, const char *name) {
    if (!info->symtab || !info->strtab || !info->hash)
        return NULL;

    /* Hash table structure: [nbucket, nchain, bucket[nbucket], chain[nchain]] */
    ElfW(Word) nbucket = info->hash[0];
    ElfW(Word) nchain = info->hash[1];
    ElfW(Word) *bucket = &info->hash[2];
    ElfW(Word) *chain = &bucket[nbucket];

    unsigned long hash = elf_hash(name);
    ElfW(Word) symidx = bucket[hash % nbucket];

    while (symidx != STN_UNDEF) {
        ElfW(Sym) *sym = &info->symtab[symidx];
        const char *sym_name = &info->strtab[sym->st_name];

        if (strcmp(sym_name, name) == 0) {
            if (sym->st_value != 0) {
                return (void *)(info->base + sym->st_value);
            }
        }

        symidx = chain[symidx];
        if (symidx >= nchain) break;  /* Safety check */
    }

    return NULL;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * FIND GOT ENTRY FOR A FUNCTION
 * ═══════════════════════════════════════════════════════════════════════════ */

void *find_got_entry(dyn_info_t *info, const char *name) {
    if (!info->jmprel || !info->pltrelsz)
        return NULL;

    size_t num_relocs = info->pltrelsz / sizeof(ElfW(Rela));

    for (size_t i = 0; i < num_relocs; i++) {
        ElfW(Rela) *rel = &info->jmprel[i];
        ElfW(Word) symidx = ELF64_R_SYM(rel->r_info);
        ElfW(Sym) *sym = &info->symtab[symidx];
        const char *sym_name = &info->strtab[sym->st_name];

        if (strcmp(sym_name, name) == 0) {
            /* rel->r_offset is the GOT entry address */
            return (void *)(info->base + rel->r_offset);
        }
    }

    return NULL;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * FIND R_DEBUG
 * ═══════════════════════════════════════════════════════════════════════════ */

struct r_debug *get_r_debug(void) {
    extern ElfW(Dyn) _DYNAMIC[];

    for (ElfW(Dyn) *dyn = _DYNAMIC; dyn->d_tag != DT_NULL; dyn++) {
        if (dyn->d_tag == DT_DEBUG) {
            return (struct r_debug *)dyn->d_un.d_ptr;
        }
    }
    return NULL;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * FIND LIBRARY IN LINK_MAP
 * ═══════════════════════════════════════════════════════════════════════════ */

struct link_map *find_library(struct r_debug *debug, const char *name) {
    for (struct link_map *lm = debug->r_map; lm != NULL; lm = lm->l_next) {
        if (lm->l_name && strstr(lm->l_name, name)) {
            return lm;
        }
    }
    return NULL;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * DEMONSTRATION
 * ═══════════════════════════════════════════════════════════════════════════ */

void demonstrate_resolution(void) {
    printf("\n");
    printf(RED "╔════════════════════════════════════════════════════════════════════╗\n" RESET);
    printf(RED "║" YELLOW "          SYMBOL RESOLUTION VIA DT_DEBUG (no dlsym!)               " RED "║\n" RESET);
    printf(RED "╚════════════════════════════════════════════════════════════════════╝\n" RESET);
    printf("\n");

    struct r_debug *debug = get_r_debug();
    if (!debug) {
        printf(RED "[!] Could not find r_debug\n" RESET);
        return;
    }

    /* Find libc */
    struct link_map *libc = find_library(debug, "libc");
    if (!libc) {
        printf(RED "[!] Could not find libc in link_map\n" RESET);
        return;
    }

    printf("[*] Found libc: %s\n", libc->l_name);
    printf("[*] Base address: " GREEN "0x%016lx" RESET "\n\n", libc->l_addr);

    /* Parse libc's dynamic section */
    dyn_info_t libc_info;
    if (parse_dynamic_section(libc, &libc_info) < 0) {
        printf(RED "[!] Could not parse libc dynamic section\n" RESET);
        return;
    }

    printf(CYAN "───────────────────────────────────────────────────────────────────\n" RESET);
    printf(CYAN "  Resolving symbols WITHOUT dlsym()\n" RESET);
    printf(CYAN "───────────────────────────────────────────────────────────────────\n" RESET);
    printf("\n");

    /* Resolve some interesting functions */
    const char *targets[] = {"system", "execve", "mprotect", "mmap", "open", "read", "write"};
    int num_targets = sizeof(targets) / sizeof(targets[0]);

    printf("  %-12s  %-20s  %-20s\n", "Function", "Resolved Address", "Offset from base");
    printf("  %-12s  %-20s  %-20s\n", "────────", "────────────────", "────────────────");

    for (int i = 0; i < num_targets; i++) {
        void *addr = resolve_symbol(&libc_info, targets[i]);
        if (addr) {
            uintptr_t offset = (uintptr_t)addr - libc_info.base;
            printf("  %-12s  " GREEN "0x%016lx" RESET "  " YELLOW "0x%08lx" RESET "\n",
                   targets[i], (uintptr_t)addr, offset);
        } else {
            printf("  %-12s  " RED "NOT FOUND" RESET "\n", targets[i]);
        }
    }

    /* Find main executable */
    printf("\n");
    printf(CYAN "───────────────────────────────────────────────────────────────────\n" RESET);
    printf(CYAN "  Finding GOT entries in main executable\n" RESET);
    printf(CYAN "───────────────────────────────────────────────────────────────────\n" RESET);
    printf("\n");

    struct link_map *main_exe = debug->r_map;
    dyn_info_t main_info;

    if (parse_dynamic_section(main_exe, &main_info) == 0) {
        const char *got_targets[] = {"puts", "printf", "malloc", "free"};
        int num_got = sizeof(got_targets) / sizeof(got_targets[0]);

        printf("  %-12s  %-20s  %-20s\n", "Function", "GOT Entry Address", "Current Value");
        printf("  %-12s  %-20s  %-20s\n", "────────", "─────────────────", "─────────────");

        for (int i = 0; i < num_got; i++) {
            void *got = find_got_entry(&main_info, got_targets[i]);
            if (got) {
                uintptr_t value = *(uintptr_t *)got;
                printf("  %-12s  " CYAN "0x%016lx" RESET "  " GREEN "0x%016lx" RESET "\n",
                       got_targets[i], (uintptr_t)got, value);
            } else {
                printf("  %-12s  " RED "NOT FOUND" RESET "\n", got_targets[i]);
            }
        }
    }

    printf("\n");
    printf(YELLOW "───────────────────────────────────────────────────────────────────\n" RESET);
    printf(YELLOW "  EXPLOITATION IMPLICATIONS\n" RESET);
    printf(YELLOW "───────────────────────────────────────────────────────────────────\n" RESET);
    printf("\n");
    printf("  With DT_DEBUG access, an attacker can:\n");
    printf("  \n");
    printf("  " RED "1." RESET " Bypass ASLR by finding library base addresses\n");
    printf("  " RED "2." RESET " Resolve ANY symbol without dlsym() (useful in shellcode)\n");
    printf("  " RED "3." RESET " Find GOT entries to hijack function calls\n");
    printf("  " RED "4." RESET " Calculate offsets that work across systems\n");
    printf("  " RED "5." RESET " Build ROP chains by finding gadgets in known locations\n");
    printf("\n");
}

int main(void) {
    demonstrate_resolution();
    return 0;
}
